{"version":3,"sources":["components/TimeseriesBrush.js"],"names":["margin","TimeseriesBrush","timeseries","dates","currentBrushSelection","endDate","lookback","setBrushSelectionEnd","setLookback","animationIndex","chartRef","useRef","useMeasure","wrapperRef","width","height","endDateMin","min","formatISO","addDays","parseIndiaDate","representation","xScale","useMemo","T","length","chartRight","scaleTime","clamp","domain","range","useEffect","chartBottom","timeseriesStacked","stack","keys","BRUSH_STATISTICS","value","date","statistic","Math","max","getStatistic","yScale","scaleLinear","svg","select","current","t","transition","duration","D3_TRANSITION_DURATION","attr","style","call","g","axisBottom","ticks","numTicksX","areaPath","area","curve","curveMonotoneX","x","d","data","y0","y1","selectAll","join","enter","append","key","STATISTIC_CONFIGS","color","update","attrTween","previous","this","interpolatePath","selection","defaultSelection","map","brush","brushX","extent","handleSize","brushed","useCallback","sourceEvent","invert","brushStartDate","brushEndDate","ReactDOM","unstable_batchedUpdates","differenceInDays","beforebrushstarted","event","brushSelection","node","dx","pointers","cx","x0","x1","X0","X1","move","brushended","on","datum","type","className","classnames","ref","onWheel","deltaX","indexOf","sign","animationDelay","preserveAspectRatio","id","y","fill","href","clipPath","mask","isEqual","prevProps","currProps","equal","regionHighlighted","stateCode","districtName","memo"],"mappings":"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","file":"static/js/47.1a9354c4.chunk.js","sourcesContent":["import {\n  BRUSH_STATISTICS,\n  D3_TRANSITION_DURATION,\n  STATISTIC_CONFIGS,\n} from '../constants';\nimport {getStatistic, parseIndiaDate} from '../utils/commonFunctions';\n\nimport classnames from 'classnames';\nimport {min, max} from 'd3-array';\nimport {axisBottom} from 'd3-axis';\nimport {brushX, brushSelection} from 'd3-brush';\nimport {interpolatePath} from 'd3-interpolate-path';\nimport {scaleTime, scaleLinear} from 'd3-scale';\nimport {select, pointers} from 'd3-selection';\nimport {area, curveMonotoneX, stack} from 'd3-shape';\nimport 'd3-transition';\nimport {addDays, differenceInDays, formatISO} from 'date-fns';\nimport equal from 'fast-deep-equal';\nimport {memo, useCallback, useMemo, useEffect, useRef} from 'react';\nimport ReactDOM from 'react-dom';\nimport {useMeasure} from 'react-use';\n\n// Chart margins\nconst margin = {top: 0, right: 35, bottom: 20, left: 25};\nconst yBufferTop = 1.2;\nconst numTicksX = (width) => (width < 480 ? 4 : 6);\nconst brushWheelDelta = 10;\n\nfunction TimeseriesBrush({\n  timeseries,\n  dates,\n  currentBrushSelection,\n  endDate,\n  lookback,\n  setBrushSelectionEnd,\n  setLookback,\n  animationIndex,\n}) {\n  const chartRef = useRef();\n  const [wrapperRef, {width, height}] = useMeasure();\n\n  const endDateMin =\n    lookback !== null\n      ? min([\n          formatISO(addDays(parseIndiaDate(dates[0]), lookback), {\n            representation: 'date',\n          }),\n          endDate,\n        ])\n      : endDate;\n\n  const xScale = useMemo(() => {\n    const T = dates.length;\n\n    // Chart extremes\n    const chartRight = width - margin.right;\n\n    return scaleTime()\n      .clamp(true)\n      .domain([\n        parseIndiaDate(dates[0] || endDate),\n        parseIndiaDate(dates[T - 1] || endDate),\n      ])\n      .range([margin.left, chartRight]);\n  }, [width, endDate, dates]);\n\n  useEffect(() => {\n    if (!width || !height) return;\n\n    // Chart extremes\n    const chartBottom = height - margin.bottom;\n\n    const xAxis = (g) =>\n      g\n        .attr('class', 'x-axis')\n        .call(axisBottom(xScale).ticks(numTicksX(width)));\n\n    // Switched to daily confirmed instead of cumulative ARD\n    const timeseriesStacked = stack()\n      .keys(BRUSH_STATISTICS)\n      .value((date, statistic) =>\n        Math.max(0, getStatistic(timeseries[date], 'delta', statistic))\n      )(dates);\n\n    const yScale = scaleLinear()\n      .clamp(true)\n      .domain([\n        0,\n        max(\n          timeseriesStacked[timeseriesStacked.length - 1],\n          ([, y1]) => yBufferTop * y1\n        ),\n      ])\n      .range([chartBottom, margin.top]);\n\n    const svg = select(chartRef.current);\n\n    const t = svg.transition().duration(D3_TRANSITION_DURATION);\n\n    svg\n      .select('.x-axis')\n      .attr('pointer-events', 'none')\n      .style('transform', `translate3d(0, ${chartBottom}px, 0)`)\n      .transition(t)\n      .call(xAxis);\n\n    const areaPath = area()\n      .curve(curveMonotoneX)\n      .x((d) => xScale(parseIndiaDate(d.data)))\n      .y0((d) => yScale(d[0]))\n      .y1((d) => yScale(d[1]));\n\n    svg\n      .select('.trend-areas')\n      .selectAll('.trend-area')\n      .data(timeseriesStacked)\n      .join(\n        (enter) =>\n          enter\n            .append('path')\n            .attr('class', 'trend-area')\n            .attr('fill', ({key}) => STATISTIC_CONFIGS[key].color)\n            .attr('fill-opacity', 0.4)\n            .attr('stroke', ({key}) => STATISTIC_CONFIGS[key].color)\n            .attr('d', areaPath)\n            .attr('pointer-events', 'none'),\n        (update) =>\n          update\n            .transition(t)\n            .attrTween('d', function (date) {\n              const previous = select(this).attr('d');\n              const current = areaPath(date);\n              return interpolatePath(previous, current);\n            })\n            .selection()\n      );\n  }, [dates, width, height, xScale, timeseries]);\n\n  const defaultSelection = currentBrushSelection.map((date) =>\n    xScale(parseIndiaDate(date))\n  );\n\n  const brush = useMemo(() => {\n    if (!width || !height) return;\n    // Chart extremes\n    const chartRight = width - margin.right;\n    const chartBottom = height - margin.bottom;\n\n    const brush = brushX()\n      .extent([\n        [margin.left, margin.top],\n        [chartRight, chartBottom],\n      ])\n      .handleSize(20);\n    return brush;\n  }, [width, height]);\n\n  const brushed = useCallback(\n    ({sourceEvent, selection}) => {\n      if (!sourceEvent) return;\n      const [brushStartDate, brushEndDate] = selection.map(xScale.invert);\n\n      ReactDOM.unstable_batchedUpdates(() => {\n        setBrushSelectionEnd(formatISO(brushEndDate, {representation: 'date'}));\n        setLookback(differenceInDays(brushEndDate, brushStartDate));\n      });\n    },\n    [xScale, setBrushSelectionEnd, setLookback]\n  );\n\n  const beforebrushstarted = useCallback(\n    (event) => {\n      const svg = select(chartRef.current);\n      const selection = brushSelection(svg.select('.brush').node());\n\n      if (!selection) return;\n\n      const dx = selection[1] - selection[0];\n      const [[cx]] = pointers(event);\n      const [x0, x1] = [cx - dx / 2, cx + dx / 2];\n      const [X0, X1] = xScale.range();\n      svg\n        .select('.brush')\n        .call(\n          brush.move,\n          x1 > X1 ? [X1 - dx, X1] : x0 < X0 ? [X0, X0 + dx] : [x0, x1]\n        );\n    },\n    [brush, xScale]\n  );\n\n  const brushended = useCallback(\n    ({sourceEvent, selection}) => {\n      if (!sourceEvent || !selection) return;\n      const domain = selection\n        .map(xScale.invert)\n        .map((date) => formatISO(date, {representation: 'date'}));\n\n      const svg = select(chartRef.current);\n      svg\n        .select('.brush')\n        .call(\n          brush.move,\n          domain.map((date) => xScale(parseIndiaDate(date)))\n        )\n        .call((g) => g.select('.overlay').attr('cursor', 'pointer'));\n    },\n    [brush, xScale]\n  );\n\n  useEffect(() => {\n    if (!brush) return;\n    brush.on('start brush', brushed).on('end', brushended);\n    const svg = select(chartRef.current);\n    svg\n      .select('.brush')\n      .call(brush)\n      .call((g) =>\n        g\n          .select('.overlay')\n          .attr('cursor', 'pointer')\n          .datum({type: 'selection'})\n          .on('mousedown touchstart', beforebrushstarted)\n      );\n  }, [brush, brushed, brushended, beforebrushstarted]);\n\n  useEffect(() => {\n    if (!brush) return;\n    const svg = select(chartRef.current);\n    svg.select('.brush').call(brush.move, defaultSelection);\n  }, [brush, defaultSelection]);\n\n  const handleWheel = (event) => {\n    if (event.deltaX) {\n      setBrushSelectionEnd(\n        max([\n          endDateMin,\n          dates[\n            Math.max(\n              0,\n              Math.min(\n                dates.length - 1,\n                dates.indexOf(currentBrushSelection[1]) +\n                  Math.sign(event.deltaX) * brushWheelDelta\n              )\n            )\n          ],\n        ])\n      );\n    }\n  };\n\n  return (\n    <div className=\"Timeseries\">\n      <div\n        className={classnames('svg-parent is-brush fadeInUp')}\n        ref={wrapperRef}\n        onWheel={handleWheel}\n        style={{animationDelay: `${animationIndex * 250}ms`}}\n      >\n        <svg ref={chartRef} preserveAspectRatio=\"xMidYMid meet\">\n          <defs>\n            <clipPath id=\"clipPath\">\n              <rect\n                x={0}\n                y={`${margin.top}`}\n                width={width}\n                height={`${Math.max(0, height - margin.bottom)}`}\n              />\n            </clipPath>\n            <mask id=\"mask\">\n              <rect\n                x={0}\n                y={`${margin.top}`}\n                width={width}\n                height={`${Math.max(0, height - margin.bottom)}`}\n                fill=\"hsl(0, 0%, 40%)\"\n              />\n              <use href=\"#selection\" fill=\"white\" />\n            </mask>\n          </defs>\n\n          <g className=\"brush\" clipPath=\"url(#clipPath)\">\n            <g mask=\"url(#mask)\">\n              <rect className=\"overlay\" />\n              <g className=\"trend-areas\" />\n              <rect className=\"selection\" id=\"selection\" />\n            </g>\n          </g>\n          <g className=\"x-axis\" />\n        </svg>\n      </div>\n    </div>\n  );\n}\n\nconst isEqual = (prevProps, currProps) => {\n  if (\n    !equal(currProps.currentBrushSelection, prevProps.currentBrushSelection)\n  ) {\n    return false;\n  } else if (\n    !equal(\n      currProps.regionHighlighted.stateCode,\n      prevProps.regionHighlighted.stateCode\n    )\n  ) {\n    return false;\n  } else if (\n    !equal(\n      currProps.regionHighlighted.districtName,\n      prevProps.regionHighlighted.districtName\n    )\n  ) {\n    return false;\n  } else if (!equal(currProps.endDate, prevProps.endDate)) {\n    return false;\n  } else if (!equal(currProps.lookback, prevProps.lookback)) {\n    return false;\n  } else if (!equal(currProps.animationIndex, prevProps.animationIndex)) {\n    return false;\n  } else if (!equal(currProps.dates, prevProps.dates)) {\n    return false;\n  }\n  return true;\n};\n\nexport default memo(TimeseriesBrush, isEqual);\n"],"sourceRoot":""}