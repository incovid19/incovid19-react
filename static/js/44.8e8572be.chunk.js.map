{"version":3,"sources":["components/TimeseriesBrush.js"],"names":["margin","TimeseriesBrush","timeseries","dates","currentBrushSelection","endDate","lookback","setBrushSelectionEnd","setLookback","animationIndex","chartRef","useRef","useMeasure","wrapperRef","width","height","endDateMin","min","formatISO","addDays","parseIndiaDate","representation","xScale","useMemo","T","length","chartRight","scaleTime","clamp","domain","range","useEffect","chartBottom","timeseriesStacked","stack","keys","BRUSH_STATISTICS","value","date","statistic","Math","max","getStatistic","yScale","scaleLinear","svg","select","current","t","transition","duration","D3_TRANSITION_DURATION","attr","style","call","g","axisBottom","ticks","numTicksX","areaPath","area","curve","curveMonotoneX","x","d","data","y0","y1","selectAll","join","enter","append","key","STATISTIC_CONFIGS","color","update","attrTween","previous","this","interpolatePath","selection","defaultSelection","map","brush","brushX","extent","handleSize","brushed","useCallback","sourceEvent","invert","brushStartDate","brushEndDate","ReactDOM","unstable_batchedUpdates","differenceInDays","beforebrushstarted","event","brushSelection","node","dx","pointers","cx","x0","x1","X0","X1","move","brushended","on","datum","type","className","classnames","ref","onWheel","deltaX","indexOf","sign","animationDelay","preserveAspectRatio","id","y","fill","href","clipPath","mask","isEqual","prevProps","currProps","equal","regionHighlighted","stateCode","districtName","memo"],"mappings":"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","file":"static/js/44.8e8572be.chunk.js","sourcesContent":["import {\r\n  BRUSH_STATISTICS,\r\n  D3_TRANSITION_DURATION,\r\n  STATISTIC_CONFIGS,\r\n} from '../constants';\r\nimport {getStatistic, parseIndiaDate} from '../utils/commonFunctions';\r\n\r\nimport classnames from 'classnames';\r\nimport {min, max} from 'd3-array';\r\nimport {axisBottom} from 'd3-axis';\r\nimport {brushX, brushSelection} from 'd3-brush';\r\nimport {interpolatePath} from 'd3-interpolate-path';\r\nimport {scaleTime, scaleLinear} from 'd3-scale';\r\nimport {select, pointers} from 'd3-selection';\r\nimport {area, curveMonotoneX, stack} from 'd3-shape';\r\nimport 'd3-transition';\r\nimport {addDays, differenceInDays, formatISO} from 'date-fns';\r\nimport equal from 'fast-deep-equal';\r\nimport {memo, useCallback, useMemo, useEffect, useRef} from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport {useMeasure} from 'react-use';\r\n\r\n// Chart margins\r\nconst margin = {top: 0, right: 35, bottom: 20, left: 25};\r\nconst yBufferTop = 1.2;\r\nconst numTicksX = (width) => (width < 480 ? 4 : 6);\r\nconst brushWheelDelta = 10;\r\n\r\nfunction TimeseriesBrush({\r\n  timeseries,\r\n  dates,\r\n  currentBrushSelection,\r\n  endDate,\r\n  lookback,\r\n  setBrushSelectionEnd,\r\n  setLookback,\r\n  animationIndex,\r\n}) {\r\n  const chartRef = useRef();\r\n  const [wrapperRef, {width, height}] = useMeasure();\r\n\r\n  const endDateMin =\r\n    lookback !== null\r\n      ? min([\r\n          formatISO(addDays(parseIndiaDate(dates[0]), lookback), {\r\n            representation: 'date',\r\n          }),\r\n          endDate,\r\n        ])\r\n      : endDate;\r\n\r\n  const xScale = useMemo(() => {\r\n    const T = dates.length;\r\n\r\n    // Chart extremes\r\n    const chartRight = width - margin.right;\r\n\r\n    return scaleTime()\r\n      .clamp(true)\r\n      .domain([\r\n        parseIndiaDate(dates[0] || endDate),\r\n        parseIndiaDate(dates[T - 1] || endDate),\r\n      ])\r\n      .range([margin.left, chartRight]);\r\n  }, [width, endDate, dates]);\r\n\r\n  useEffect(() => {\r\n    if (!width || !height) return;\r\n\r\n    // Chart extremes\r\n    const chartBottom = height - margin.bottom;\r\n\r\n    const xAxis = (g) =>\r\n      g\r\n        .attr('class', 'x-axis')\r\n        .call(axisBottom(xScale).ticks(numTicksX(width)));\r\n\r\n    // Switched to daily confirmed instead of cumulative ARD\r\n    const timeseriesStacked = stack()\r\n      .keys(BRUSH_STATISTICS)\r\n      .value((date, statistic) =>\r\n        Math.max(0, getStatistic(timeseries[date], 'delta', statistic))\r\n      )(dates);\r\n\r\n    const yScale = scaleLinear()\r\n      .clamp(true)\r\n      .domain([\r\n        0,\r\n        max(\r\n          timeseriesStacked[timeseriesStacked.length - 1],\r\n          ([, y1]) => yBufferTop * y1\r\n        ),\r\n      ])\r\n      .range([chartBottom, margin.top]);\r\n\r\n    const svg = select(chartRef.current);\r\n\r\n    const t = svg.transition().duration(D3_TRANSITION_DURATION);\r\n\r\n    svg\r\n      .select('.x-axis')\r\n      .attr('pointer-events', 'none')\r\n      .style('transform', `translate3d(0, ${chartBottom}px, 0)`)\r\n      .transition(t)\r\n      .call(xAxis);\r\n\r\n    const areaPath = area()\r\n      .curve(curveMonotoneX)\r\n      .x((d) => xScale(parseIndiaDate(d.data)))\r\n      .y0((d) => yScale(d[0]))\r\n      .y1((d) => yScale(d[1]));\r\n\r\n    svg\r\n      .select('.trend-areas')\r\n      .selectAll('.trend-area')\r\n      .data(timeseriesStacked)\r\n      .join(\r\n        (enter) =>\r\n          enter\r\n            .append('path')\r\n            .attr('class', 'trend-area')\r\n            .attr('fill', ({key}) => STATISTIC_CONFIGS[key].color)\r\n            .attr('fill-opacity', 0.4)\r\n            .attr('stroke', ({key}) => STATISTIC_CONFIGS[key].color)\r\n            .attr('d', areaPath)\r\n            .attr('pointer-events', 'none'),\r\n        (update) =>\r\n          update\r\n            .transition(t)\r\n            .attrTween('d', function (date) {\r\n              const previous = select(this).attr('d');\r\n              const current = areaPath(date);\r\n              return interpolatePath(previous, current);\r\n            })\r\n            .selection()\r\n      );\r\n  }, [dates, width, height, xScale, timeseries]);\r\n\r\n  const defaultSelection = currentBrushSelection.map((date) =>\r\n    xScale(parseIndiaDate(date))\r\n  );\r\n\r\n  const brush = useMemo(() => {\r\n    if (!width || !height) return;\r\n    // Chart extremes\r\n    const chartRight = width - margin.right;\r\n    const chartBottom = height - margin.bottom;\r\n\r\n    const brush = brushX()\r\n      .extent([\r\n        [margin.left, margin.top],\r\n        [chartRight, chartBottom],\r\n      ])\r\n      .handleSize(20);\r\n    return brush;\r\n  }, [width, height]);\r\n\r\n  const brushed = useCallback(\r\n    ({sourceEvent, selection}) => {\r\n      if (!sourceEvent) return;\r\n      const [brushStartDate, brushEndDate] = selection.map(xScale.invert);\r\n\r\n      ReactDOM.unstable_batchedUpdates(() => {\r\n        setBrushSelectionEnd(formatISO(brushEndDate, {representation: 'date'}));\r\n        setLookback(differenceInDays(brushEndDate, brushStartDate));\r\n      });\r\n    },\r\n    [xScale, setBrushSelectionEnd, setLookback]\r\n  );\r\n\r\n  const beforebrushstarted = useCallback(\r\n    (event) => {\r\n      const svg = select(chartRef.current);\r\n      const selection = brushSelection(svg.select('.brush').node());\r\n\r\n      if (!selection) return;\r\n\r\n      const dx = selection[1] - selection[0];\r\n      const [[cx]] = pointers(event);\r\n      const [x0, x1] = [cx - dx / 2, cx + dx / 2];\r\n      const [X0, X1] = xScale.range();\r\n      svg\r\n        .select('.brush')\r\n        .call(\r\n          brush.move,\r\n          x1 > X1 ? [X1 - dx, X1] : x0 < X0 ? [X0, X0 + dx] : [x0, x1]\r\n        );\r\n    },\r\n    [brush, xScale]\r\n  );\r\n\r\n  const brushended = useCallback(\r\n    ({sourceEvent, selection}) => {\r\n      if (!sourceEvent || !selection) return;\r\n      const domain = selection\r\n        .map(xScale.invert)\r\n        .map((date) => formatISO(date, {representation: 'date'}));\r\n\r\n      const svg = select(chartRef.current);\r\n      svg\r\n        .select('.brush')\r\n        .call(\r\n          brush.move,\r\n          domain.map((date) => xScale(parseIndiaDate(date)))\r\n        )\r\n        .call((g) => g.select('.overlay').attr('cursor', 'pointer'));\r\n    },\r\n    [brush, xScale]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!brush) return;\r\n    brush.on('start brush', brushed).on('end', brushended);\r\n    const svg = select(chartRef.current);\r\n    svg\r\n      .select('.brush')\r\n      .call(brush)\r\n      .call((g) =>\r\n        g\r\n          .select('.overlay')\r\n          .attr('cursor', 'pointer')\r\n          .datum({type: 'selection'})\r\n          .on('mousedown touchstart', beforebrushstarted)\r\n      );\r\n  }, [brush, brushed, brushended, beforebrushstarted]);\r\n\r\n  useEffect(() => {\r\n    if (!brush) return;\r\n    const svg = select(chartRef.current);\r\n    svg.select('.brush').call(brush.move, defaultSelection);\r\n  }, [brush, defaultSelection]);\r\n\r\n  const handleWheel = (event) => {\r\n    if (event.deltaX) {\r\n      setBrushSelectionEnd(\r\n        max([\r\n          endDateMin,\r\n          dates[\r\n            Math.max(\r\n              0,\r\n              Math.min(\r\n                dates.length - 1,\r\n                dates.indexOf(currentBrushSelection[1]) +\r\n                  Math.sign(event.deltaX) * brushWheelDelta\r\n              )\r\n            )\r\n          ],\r\n        ])\r\n      );\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"Timeseries\">\r\n      <div\r\n        className={classnames('svg-parent is-brush fadeInUp')}\r\n        ref={wrapperRef}\r\n        onWheel={handleWheel}\r\n        style={{animationDelay: `${animationIndex * 250}ms`}}\r\n      >\r\n        <svg ref={chartRef} preserveAspectRatio=\"xMidYMid meet\">\r\n          <defs>\r\n            <clipPath id=\"clipPath\">\r\n              <rect\r\n                x={0}\r\n                y={`${margin.top}`}\r\n                width={width}\r\n                height={`${Math.max(0, height - margin.bottom)}`}\r\n              />\r\n            </clipPath>\r\n            <mask id=\"mask\">\r\n              <rect\r\n                x={0}\r\n                y={`${margin.top}`}\r\n                width={width}\r\n                height={`${Math.max(0, height - margin.bottom)}`}\r\n                fill=\"hsl(0, 0%, 40%)\"\r\n              />\r\n              <use href=\"#selection\" fill=\"white\" />\r\n            </mask>\r\n          </defs>\r\n\r\n          <g className=\"brush\" clipPath=\"url(#clipPath)\">\r\n            <g mask=\"url(#mask)\">\r\n              <rect className=\"overlay\" />\r\n              <g className=\"trend-areas\" />\r\n              <rect className=\"selection\" id=\"selection\" />\r\n            </g>\r\n          </g>\r\n          <g className=\"x-axis\" />\r\n        </svg>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst isEqual = (prevProps, currProps) => {\r\n  if (\r\n    !equal(currProps.currentBrushSelection, prevProps.currentBrushSelection)\r\n  ) {\r\n    return false;\r\n  } else if (\r\n    !equal(\r\n      currProps.regionHighlighted.stateCode,\r\n      prevProps.regionHighlighted.stateCode\r\n    )\r\n  ) {\r\n    return false;\r\n  } else if (\r\n    !equal(\r\n      currProps.regionHighlighted.districtName,\r\n      prevProps.regionHighlighted.districtName\r\n    )\r\n  ) {\r\n    return false;\r\n  } else if (!equal(currProps.endDate, prevProps.endDate)) {\r\n    return false;\r\n  } else if (!equal(currProps.lookback, prevProps.lookback)) {\r\n    return false;\r\n  } else if (!equal(currProps.animationIndex, prevProps.animationIndex)) {\r\n    return false;\r\n  } else if (!equal(currProps.dates, prevProps.dates)) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nexport default memo(TimeseriesBrush, isEqual);\r\n"],"sourceRoot":""}